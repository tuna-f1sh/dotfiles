#!/usr/bin/env bash

if [[ $OSTYPE =~ "darwin" ]]; then
  function ff { osascript -e 'tell application "Finder"'\
   -e "if (${1-1} <= (count Finder windows)) then"\
    -e "get POSIX path of (target of window ${1-1} as alias)"\
     -e 'else' -e 'get POSIX path of (desktop as alias)'\
      -e 'end if' -e 'end tell'; };

  function cdff { cd "`ff $@`"; };
fi

# Codi
# Usage: codi [filetype] [filename]
codi() {
  local syntax="${1:-python}"
  shift
  $EDITOR -c \
    "let g:startify_disable_at_vimenter = 1 |\
    set bt=nofile ls=0 noru nonu nornu |\
    hi ColorColumn ctermbg=NONE |\
    hi VertSplit ctermbg=NONE |\
    hi NonText ctermfg=0 |\
    Codi $syntax" "$@"
}

# FZF
#==================

# fze [FUZZY PATTERN] - Open the selected file with the default editor
#   - Bypass fuzzy finder if there's only one match (--select-1)
#   - Exit if there's no match (--exit-0)
fze() {
  local files
  IFS=$'\n' files=($(fzf-tmux --query="$1" --multi --select-1 --exit-0 --preview 'head -n 100 {}'))
  [[ -n "$files" ]] && ${EDITOR:-vim} "${files[@]}"
}

# Modified version where you can press
#   - CTRL-O to open with `open` command,
#   - CTRL-E or Enter key to open with the $EDITOR
fzo() {
  local out file key
  IFS=$'\n' out=($(fzf-tmux --query="$1" --exit-0 --expect=ctrl-o,ctrl-e))
  key=$(head -1 <<< "$out")
  file=$(head -2 <<< "$out" | tail -1)
  if [ -n "$file" ]; then
    [ "$key" = ctrl-o ] && open "$file" || ${EDITOR:-vim} "$file"
  fi
}

# fzd - cd to selected directory
fzd() {
  local dir
  dir=$(find ${1:-.} -path '*/\.*' -prune \
                  -o -type d -print 2> /dev/null | fzf +m) &&
  cd "$dir"
}

# fh - repeat history
fzh() {
  print -z $( ([ -n "$ZSH_NAME" ] && fc -l 1 || history) | fzf +s --tac | sed 's/ *[0-9]* *//')
}

# fbr - checkout git branch (including remote branches), sorted by most recent commit, limit 30 last branches
fbr() {
  local branches branch
  branches=$(git for-each-ref --count=30 --sort=-committerdate refs/heads/ --format="%(refname:short)") &&
  branch=$(echo "$branches" |
           fzf-tmux -d $(( 2 + $(wc -l <<< "$branches") )) +m) &&
  git checkout $(echo "$branch" | sed "s/.* //" | sed "s#remotes/[^/]*/##")
         }

# Git preview files to add
gfzf() {
  (git rev-parse HEAD > /dev/null 2>&1) || return
  git -c color.status=always status --short |
  fzf -m --ansi --nth 2..,.. \
    --preview '(git diff --color=always -- {-1} | sed 1,4d; cat {-1}) | head -500' |
  cut -c4- | sed 's/.* -> //'
}

# Git browse history
gfzh() {
  (git rev-parse head > /dev/null 2>&1) || return
  git log --date=short --format="%c(green)%c(bold)%cd %c(auto)%h%d %s (%an)" --graph --color=always |
  fzf --ansi --no-sort --reverse --multi --bind 'ctrl-s:toggle-sort' \
    --header 'press ctrl-s to toggle sort' \
    --preview 'grep -o "[a-f0-9]\{7,\}" <<< {} | xargs git show --color=always | head -'$lines |
  grep -o "[a-f0-9]\{7,\}"
}

# fshow - git commit browser
fzshow() {
  git log --graph --color=always \
      --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" "$@" |
  fzf --ansi --no-sort --reverse --tiebreak=index --bind=ctrl-s:toggle-sort \
      --bind "ctrl-m:execute:
                (grep -o '[a-f0-9]\{7\}' | head -1 |
                xargs -I % sh -c 'git show --color=always % | less -R') << 'FZF-EOF'
                {}
FZF-EOF"
}

# fstash - easier way to deal with stashes
# type fstash to get a list of your stashes
# enter shows you the contents of the stash
# ctrl-d shows a diff of the stash against your current HEAD
# ctrl-b checks the stash out as a branch, for easier merging
fzstash() {
  local out q k sha
  while out=$(
    git stash list --pretty="%C(yellow)%h %>(14)%Cgreen%cr %C(blue)%gs" |
    fzf --ansi --no-sort --query="$q" --print-query \
        --expect=ctrl-d,ctrl-b);
  do
    mapfile -t out <<< "$out"
    q="${out[0]}"
    k="${out[1]}"
    sha="${out[-1]}"
    sha="${sha%% *}"
    [[ -z "$sha" ]] && continue
    if [[ "$k" == 'ctrl-d' ]]; then
      git diff $sha
    elif [[ "$k" == 'ctrl-b' ]]; then
      git stash branch "stash-$sha" $sha
      break;
    else
      git stash show -p $sha
    fi
  done
}

# cdf - cd into the directory of the selected file
cdf() {
   local file
   local dir
   file=$(fzf +m -q "$1") && dir=$(dirname "$file") && cd "$dir"
}

# Ag for term to edit in nvim with preview
agvim() {
  local file
  local line

  read -r file line <<<"$(ag --nobreak --noheading $@ | fzf -0 -1 | awk -F: '{print $1, $2}')"

  if [[ -n $file ]]
  then
     $EDITOR $file +$line
  fi
}

# fkill - kill process
fkill() {
  local pid
  pid=$(ps -ef | sed 1d | fzf -m | awk '{print $2}')

  if [ "x$pid" != "x" ]
  then
    echo $pid | xargs kill -${1:-9}
  fi
}

# Note taking function and command completion
_n() {
  local lis cur
  lis=$(fd . "${NOTE_DIR}" -e md | \
    sed -e "s|${NOTE_DIR}/||" | \
    sed -e 's/\.md$//')
  cur=${COMP_WORDS[COMP_CWORD]}
  COMPREPLY=( $(compgen -W "$lis" -- "$cur") )
}
note() {
  : "${NOTE_DIR:?'NOTE_DIR ENV Var not set'}"
  if [ $# -eq 0 ]; then
    local file
    file=$(fd . "${NOTE_DIR}" -e md | \
      sed -e "s|${NOTE_DIR}/||" | \
      sed -e 's/\.md$//' | \
      sort -k 1 -n -r | \
      fzf \
        --multi \
        --select-1 \
        --exit-0 \
        --preview="cat ${NOTE_DIR}/{}.md" \
        --preview-window=right:60%:wrap)
    [[ -n $file ]] && \
      ${EDITOR:-vim} "${NOTE_DIR}/${file}.md"
  else
    case "$1" in 
      "-d")
        rm "${NOTE_DIR}"/"$2".md
        ;;
      "-cd")
        cd ${NOTE_DIR}
        ;;
      "-a")
        local file="$(date +%Y-%m-%d-%H-%M)"
        ${EDITOR:-vim} "${NOTE_DIR}/${file}.md"
        ;;
      "-j")
        local file="journal-$(date +%Y-%m).md"
        echo "\n## $(date +%c)" >> "${NOTE_DIR}/${file}"
        ${EDITOR:-vim} "${NOTE_DIR}/${file}"
        ;;
      "-p")
        local file
        file=$(fd . "${NOTE_DIR}/pocket" -e md -e txt | \
          sed -e "s|${NOTE_DIR}/pocket||" | \
          sort -k 1 -n -r | \
          fzf \
            --multi \
            --select-1 \
            --exit-0 \
            --preview="cat ${NOTE_DIR}/pocket{}" \
            --preview-window=right:60%:wrap)
        [[ -n $file ]] && \
          ${EDITOR:-vim} "${NOTE_DIR}/${file}"
        ;;
      "-s")
        local file
        if [ -z "$2" ]; then
          file=$(rg . --type markdown ${NOTE_DIR} | \
            sed -e "s|${NOTE_DIR}/||" | \
            sed -e 's/\.md//' | \
            fzf \
              -i \
              --exact \
              --multi \
              --select-1 \
              --exit-0 | \
              awk -F: '{print $1}')
        else
          file=$(ag --nobreak --nonumbers --noheading --markdown -l "$2" ${NOTE_DIR} | \
            sed -e "s|${NOTE_DIR}/||" | \
            sed -e 's/\.md$//' | \
            fzf \
              -i \
              --exact \
              --multi \
              --select-1 \
              --exit-0 \
              --preview="cat ${NOTE_DIR}/{}.md" \
              --preview-window=right:60%:wrap | \
              awk -F: '{print $1}')
        fi
        [[ -n $file ]] && \
          ${EDITOR:-vim} "${NOTE_DIR}"/"${file}".md
        ;;
      *)
        ${EDITOR:-vim} "${NOTE_DIR}"/"$*".md
        ;;
    esac
  fi
}
complete -F _n note

# Override Z for use with fzf
unalias z 2> /dev/null
z() {
  if [[ -z "$*" ]]; then
    cd "$(_z -l 2>&1 | fzf +s --tac | sed 's/^[0-9,.]* *//')"
  else
    _z "$@"
  fi
}

# Todo List & Completion
_todo() {
  local iter use cur
  cur=${COMP_WORDS[COMP_CWORD]}
  use=$( awk '{gsub(/ /,"\\ ")}8' "$TODOFILE" )
  use="${use//\\ /___}"
  for iter in $use; do
    if [[ $iter =~ ^$cur ]]; then
      COMPREPLY+=( "${iter//___/ }" )
    fi
  done
}
todo() {
  : "${TODO:?'TODO ENV Var not set. Please set to path of default todo file.'}"
  TODOFILE=$TODO
  TODOARCHIVEFILE=${TODO%.*}.archive.md

  if [ $# -eq 0 ]; then
    if [ -f "$TODOFILE" ] ; then
      awk '{ print NR, "-", $0 }' "$TODOFILE"
    fi
  else
    case "$1" in
      -h|--help)
        echo "todo - Command Line Todo List Manager"
        echo " "
        echo "Creates a text-based todo list and provides basic operations to add and remove elements from the list. If using TMUX, the todo list is session based, using the name of your active session."
        echo " "
        echo "usage: todo                                 # display todo list"
        echo "usage: todo (--help or -h)                  # show this help"
        echo "usage: todo (--add or -a) [activity name]   # add a new activity to list"
        echo "usage: todo (--archive)                     # show completed tasks in archive list"
        echo "usage: todo (--done or -d) [name or #]      # complete and archive activity"
        ;;
      -a|--add)
        echo "${*:2}" >> "$TODOFILE"
        ;;
      -d|--done)
        re='^[0-9]+$'
        if ! [[ "$2" =~ $re ]] ; then
          match=$(sed -n "/$2/p" "$TODOFILE" 2> /dev/null)
          sed -i "" -e "/$2/d" "$TODOFILE" 2> /dev/null
        else
          match=$(sed -n "$2p" "$TODOFILE" 2> /dev/null)
          sed -i "" -e "$2d" "$TODOFILE" 2> /dev/null
        fi
        if [ ! -z "$match" ]; then
          echo "$(date +"%Y-%m-%d %H:%M:%S") - $match" >> "$TODOARCHIVEFILE"
        fi
        ;;
    esac
  fi

}

# find todo notes in current project
function todos {
  LOCAL_DIR=$(git rev-parse --show-toplevel 2> /dev/null)
  LOCAL_DIR=${LOCAL_DIR:-.}
  if [ $# -eq 0 ]; then
    ag '(\bTODO\b|\bFIX(ME)?\b|\bREFACTOR\b)' ${LOCAL_DIR}
  else
    ag ${*:1} '(\bTODO\b|\bFIX(ME)?\b|\bREFACTOR\b)' ${LOCAL_DIR}
  fi
}

# git ignore
function gi() { curl -L -s https://www.gitignore.io/api/\$@ ;}

# create html from markdown in GitHub CSS
function mdhtml {
  FILE="$1"
  pandoc "$1" --to=html5 --css=${HOME}/dotfiles/support/github.css --highlight-style=haddock  --self-contained --output "${FILE%%.*}".html
}
